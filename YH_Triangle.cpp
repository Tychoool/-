#include <stdio.h>
typedef long long int LL;
int n;
LL max(int a, int b)
{
    LL max = a;
    if (b > a) max = b;
    return max;
}
LL C(int a, int b)//a>=b,求组合数
{
    if (b == 0 || a == b)return 1;
    LL res = 1;
    for (int i = a, j = 1; j <= b; i--, j++)
    {
        res = (res * i) / j;//这里有细节是先进行res*i这个运算，保证此运算可以整除
        if (res > n)
            return res;
    }
    return res;
}
int check(int k)//check使用斜二分查找
{
    /*下面解决的问题是：确定了从第k斜行开始检查，我该从该斜行的哪一行开始寻找n？
    定义：r是要找的数n的行号，k是斜行的序号（也是n的列号），L是该斜行的第一个数的行数*/
    LL l, r, mid;
    l = 2 * k;//比如第16斜行的第一个数的行数是32，L就是32，L就是检查的起点
    r = max(n, l);
    /*第二斜行是正整数序列，举个例子：我要查找10，然后第10行的第二个（也就是处于第二斜行上）
    是10,我肯定能找到它，不需要往下检查了，但是这并不是第一次出现10,10在第5行就出现过了，
    能确定的是 10第一次出现的行数一定≤10 
    推广以后：我要查n，最多查到第n行就行。而L是最小行数，正常情况L肯定比n小，
    那可以直接写r=n吗？不可以，因为n是你输入的东西，
    n可能为负数可能为0。我觉得应该改成：
    if（n<1)
       cout<<"不存在"<<endl;
    else
       r=n;
    还有原注解的C(n,2)=n是错误式子，应该是C（n，1）=n，第二斜行是C（n，1），第三斜行是C（n，2）
    （原文）:边界取n是因为一定存在C(n,2)=n此时在第二斜行，第二斜行有从1开始的所有整数*/
    
    while (r > l) //能进入循环说明r＞L也就是上面取的是r=n。
    {
        int mid = (l+ r) / 2; //第一次的时候，l是最小行数，r=n是最大行数，mid的值是取对半
        if (C(mid, k) >= n)/*第i行第j列的值是C(i，j)。若第mid行第k列的数比n大，
                            说明n可能在第mid行里面，所以先让行数r=mid*/
            r = mid;
        else l = mid + 1;/*反之，若这一行的数比n小，那我让L变大，因为mid = (L+ r) / 2，L变大了，
                         则mid变大，mid往下一行，C(mid, k)也变大了，如果满足>= n就说明
                         n可能在第mid行，r就有落脚点了*/
    }/*假如第一次就成功r=mid，因为mid是大于L的，还会继续循环，相当于mid一直取对半，
     r又等于mid，r越来越接近那个唯一确定的行数。
     取对半的好处是，假如我要找999999，而L初始是32，对半以后mid变成500015，
     如果n不在第500015行，L就变成500016，
     你可以发现L从32跃到了500016，对半取是很快的，不用一行一行加。。。*/

    //循环结束，得到了唯一确定的r值

    if (C(r, k) != n)/*看看C(r，k)是不是要找的n值，结果不是，
                      从main函数可以知道这个斜行的检查结束了，去检查下一个斜行*/
    {
        return 0;
    }
    else {
        printf("%lld", (r + 1) * r / 2 + k + 1);
        /*找到了，(r + 1) * r / 2 + k + 1是计算要找的数是第几个*/
        return 1;n
    }
}
int main()
{
    scanf("%d", &n);
    //i取16是因为C(34,17)已经超过题目中n的范围
    for (int i = 16; ; i--) {
        if (check(i))
            break;
    }
    return 0;
}